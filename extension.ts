import * as vscode from "vscode";

import { Configuration } from "./src/configuration/configuration";
import { organizeTypes } from "./src/helpers/code-helper";

// #region Functions (3)

export function activate(context: vscode.ExtensionContext)
{
    context.subscriptions.push(vscode.commands.registerCommand('tsco.organize', () => organizeEditor(vscode.window.activeTextEditor, configuration)));
    context.subscriptions.push(vscode.commands.registerCommand('tsco.organizeAll', () => organizeAll(configuration)));

    vscode.workspace.onDidChangeConfiguration(e => configuration = Configuration.getConfiguration())

    vscode.workspace.onWillSaveTextDocument(e =>
    {
        if (e.reason === vscode.TextDocumentSaveReason.Manual &&
            e.document.fileName == vscode.window.activeTextEditor?.document?.fileName &&
            configuration.organizeOnSave)
        {
            organizeEditor(vscode.window.activeTextEditor, Configuration.getConfiguration());
        }
    });
}

function organizeEditor(editor: vscode.TextEditor | undefined, configuration: Configuration) {
    return organize(editor?.document, configuration);
}

function organize(document: vscode.TextDocument | undefined, configuration: Configuration)
{
    const ignoreComment1Regex = new RegExp("//\\s*tsco:ignore");
    const ignoreComment2Regex = new RegExp("//\\s*<auto-generated\\s*/>");

    if (document)
    {
        const sourceCode = document.getText();

        if (!ignoreComment1Regex.test(sourceCode) &&
            !ignoreComment2Regex.test(sourceCode))
        {
            const organizedSourceCode = organizeTypes(sourceCode, document.fileName, configuration);

            if (organizedSourceCode !== sourceCode)
            {
                const start = new vscode.Position(0, 0);
                const end = new vscode.Position(document.lineCount, document.lineAt(document.lineCount - 1).text.length);
                const range = new vscode.Range(start, end);
                const edit = new vscode.WorkspaceEdit();

                edit.replace(document.uri, range, organizedSourceCode);

                return vscode.workspace.applyEdit(edit);
            }
        }
    }
}

function organizeAll(configuration: Configuration)
{
    vscode.workspace.findFiles("**/*.ts", "**/node_modules/**")
        .then(typescriptFiles => typescriptFiles.forEach(typescriptFile => vscode.workspace.openTextDocument(typescriptFile)
            .then(document => vscode.window.showTextDocument(document)
                .then(editor => organize(editor.document, configuration) !== null))));
}

// #endregion Functions (3)

// #region Providers (1)

const COMMAND = 'source.fix.tsco';

export class Organizer implements vscode.CodeActionProvider {
    public static readonly providedCodeActionKinds = [
        vscode.CodeActionKind.Source,
	];

	public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] | undefined {
        const organizeFile = this.createOrganizeFileCommand();
        return [
            organizeFile
        ]
    }

    private createOrganizeFileCommand(): vscode.CodeAction {
		const action = new vscode.CodeAction('Learn more...', vscode.CodeActionKind.Source);
		action.command = { command: COMMAND, title: 'Reorganize Class', tooltip: 'This will reorganize the class members in the current file' };
		return action;
	}
}


// #region Variables (1)

let configuration = Configuration.getConfiguration();

// #endregion Variables (1)
